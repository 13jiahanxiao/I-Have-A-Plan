
# 第一周算法总结
---
PS：由于错过了回家的车改签到后一天以至于要在南京呆一晚上（然后在肯德基里做完了一堆题目和写下了这篇总结）。
## 总述
太久没有写c++程序了，所以这几个小时做的题目主要以恢复手感为主，挑了几道较为简单的动态规划和深度搜索来做。虽说题目简单，但是依然还是在边界处理方面出了些问题。水题一般来说会对边界条件有着更加严格的要求，在做题时就算放松，在边界方面也要打起精神多加注意。
## 做题记录
![……不知道为什么在视图里面显示不出来] [https://raw.githubusercontent.com/muzixu/SummerHolidayPlan/master/image/FinishedSubjectsIn2019_7_1.png](https://raw.githubusercontent.com/muzixu/SummerHolidayPlan/master/image/FinishedSubjectsIn2019_7_1.png)
## 题目分析

### 爬楼梯

* 题目要求：假设你正在爬楼梯。需要  _n_ 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
* 题目难度：简单
* 题目类型：动态规划
* 题目思路：跟青蛙过河并称的动态规划基础题目之一。每一步的状态只能从前一步和前两步来，甚至不需要dp数组，列出前几步以后就会发现这题是很明显的斐波那契数列。找到规律后，使用三个int变量的空间即可。理论时间复杂度为O(n)。
* 核心代码：c=a+b; b=c; a=b;
* 做题结果：通过/提交：1/1
       执行用时超88.16%  C++代码
 * 时间最优解：这道题最优解反而是使用vector建立了一个比较大的dp数组进行循环计算。次数也没有变少，想不明白为什么会让时间减少。本质上时间复杂度没变，参考价值不大。
 
### 2的幂

* 题目要求：给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
* 题目难度：简单
* 题目类型：水题
* 题目思路：这道题交了三遍才过，着实丢人。我的核心思路为利用c++自带的%求余符号，一路往下循环，直到剩余1前，凡是%2不为0则不为2的幂次方。  交了两次学费都是关于边界方面。0不为2的幂次方，负数同理。这两种只需要写一个小于等于0的判断，但是由于一看水题就没有太集中，导致丢人现象发生。需警醒。
* 核心代码：if(n%2!=0) return false;n=n/2;
* 做题结果：通过/提交：1/3
   执行用时超100% C++代码
* 时间最优解：不知道为什么我这种为最优，理论上我的时间复杂度为O(log2)级别，还是需要时间的。而看完题解中大多都是使用位运算，因为2的幂次方有个鲜明特点：在二进制下只有一位0，且必定为首位。故2^n^与2^n^-1进行与运算的结果为0。后来猜想c++进行位运算也需要变换成二进制依次比较，时间复杂度仍为O(log2)级别（十进制转二进制的短除法时间复杂度）。

### 岛屿数量

* 题目要求：给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。
* 题目难度：中等
* 题目类型：深/宽度搜索
* 题目思路：由于数据量较小（<50），可以肆无忌惮使用深度搜索（代码编写相对宽度搜索较为简单）。遍历地图，每当找到一个陆地，计数器加一，并且将此陆地通过dfs（深搜）全部标记或变为水域。遍历完成输出结果即可。时间复杂度方面由于对地图有永久性改变，与回溯算法不同，复杂度理论上n^2^+n^2^仍为平方级运算（即O（n^2^））。
* 核心代码：if (m<0 || n<0 || n>=grid.size() ||m>=grid[0].size()) return;
        if (grid[n][m]=='0') return;
        grid[n][m]='0';
        Dfs(四周);
 * 做题结果：通过/提交：1/1
执行用时超98.42% C++代码
* 时间最优解：算法方面仍是用DFS，但是采用了C++11重写的auto关键字。查阅资料并没有提起使用auto关键字能提高程序运行效率（缩短代码长度倒是很常见）。今天做这一串题下来发现最前面的程序会经常使用这种模式。具体效果有待求证。

### 岛屿的最大面积

* 题目要求：与上题同背景，找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)
* 题目难度：中等
* 题目类型：深/宽度搜索
* 题目思路：同为深搜，在判断条件上有着略微的改变。改变地图的同时，需要引用一个int变量来记录当前深度搜索的陆地个数，遍历完以后将最大值输出。
  由于以前的习惯，没有采用引用变量的方式，而是将Dfs的函数类型改成了int，这样可以简化代码增加可读性，也无需在参数表引用多一个参数。相对而言，缺点是void改成int类型后，每次深搜都会返回值，变相增加了赋值操作的执行次数，时间复杂度会上升。
* 核心代码：if (m<0 || n<0 || n>=grid.size() || m>=	grid[0].size()) return 0;
		if (grid[n][m] == 0) return 0;
		grid[n][m] = 0;
		return 
		Dfs(grid, n - 1, m)+Dfs(grid, n, m - 1)+Dfs(grid, n + 1, m)+Dfs(grid, n, m + 1)+1;
 * 做题结果：通过/提交：1/1
执行用时超89.91% C++代码
* 时间最优解：最优解采用参数表引用的方式，保证了深搜函数本身的操作尽可能少，如果我将函数类型改回void应该能进一步减少时间消耗。

### 岛屿周长

* 题目要求：与上题同背景，给定网格有且只有一个陆地，求陆地的周长。

* 题目难度：中等
* 题目类型：深/宽度搜索
* 题目思路：我依旧使用深搜方法，但这次运用了规律。深搜核心代码在下一层语句前或者后决定了语句的执行顺序。这次我采取核心代码放在进入下一层代码的后面，这样可以达到判断该陆地时，四周陆地已被标记的效果。
       我得出的规律：一块陆地能提供多少周长，取决于该陆地周围有多少陆地。若周围陆地数为4，则说明该陆地被其他陆地完全包围，不能提供任何周长。相对应的，在周围陆地为3，2，1，0时，提供周长分别为1，2，3，4。执行时，找到一块陆地，先将其周围搜索完（类似于树的后序遍历）最后判断自身能提供多少周长，加到计数器中。最后输出计数器数值即可。其次，由于0为水域，所以为了减少代码量取了个巧，即将搜索过的陆地值设置为2，初始提供周长设置为8，周围每有一块陆地就减2，最后得出两倍周长，/2即为正确结果。
* 核心代码：if (m<0 || n<0 || n>=grid.size() || m>=	grid[0].size()) return;
		if (grid[n][m] == 0) return;
		if (grid[n][m] == 2) return;
		grid[n][m] = 2;
		DFS（四周）
		int sum = 8;
		sum=sum-（（四周土地数）/2）；
		ans=ans+sum;
 * 做题结果：通过/提交：1/1
执行用时超93.86% C++代码
* 时间最优解：这次最优解确实给了我很大启发。在已知陆地有且仅有一块的情况下，其实根本就不需要用到深度搜索，直接双重循环即可解决。
      深度搜索效果是找到一块联通区域，但该题条件为地图中有且仅有一块联通区域，所以所有土地都是直接连载一起的，可以直接开始算周长。
      算周长方法：找到陆地，若陆地挨着边界，则每挨一条边界，周长+1。（贴墙则该边长度不会被阻挡）。其次，左右上下搜索，若左右上下不为土地，则对应边长+1。搜索完地图即可得出结果。
      
 ### 图像渲染

* 题目要求：有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小。
给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
* 题目难度：简单
* 题目类型：深/宽度搜索
* 题目思路：需要实现类似于PS 颜料桶的功能，将选定区域所有相同元素值的区域全部更换成另一个值。
    在图像处理这方面，宽度搜索一直效率是比深度搜索要高的。但是我还是使用了深度搜索（代码少）。还是一个最基本的Dfs，只是这次核心操作要放在进入下一层代码的后面，或者先将颜色值拿出来再改变自己的颜色值（因为要跟周围做匹配）。
    
* 核心代码：if (sr < 0 || sc < 0 || sr >= image.size() || sc >= image[0].size())return image;
		int com = image[sr][sc]; 
		image[sr][sc] = -1;
		DFS（四周）
		image[sr][sc] = newColor;
		return image;
 * 做题结果：通过/提交：1/1
执行用时超75.46% C++代码
* 时间最优解：最优解确实是使用宽度搜索的方法。范围越大，要修改的数值越密集，则宽度搜索优势越大。深度搜索只适用于小规模的搜索，一般来说100*100就差不多是极限了。

### 不同路径

* 题目要求：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？
* 题目难度：中等
* 题目类型：动态规划
* 题目思路：虽然有点不明白为什么会归到中等难度这一栏……二维青蛙跳，也称为过河卒问题。
    机器人只能向下向右走，递归思想来看，终点道路只能从上从左来。确定完规则后，则先进行初始化处理，将第一行与第一列全部初始化为1，随后开始二重循环。动态规划其实只要想出那条关键式子，核心代码最多四五句话左右。（递归转递推思想）
    
* 核心代码：obj[i][j] =obj[i-1][j]+obj[i][j-1];
                 return obj[n-1][m-1];
 * 做题结果：通过/提交：1/1
执行用时超100% C++代码
* 时间最优解：……肉眼可见的最优解。初始化做好可以将各种边界要求降到最低。

*  ### 不同路径（2）

* 题目要求：条件同上题，出现障碍物，标记为1（不可通过）
* 题目难度：中等
* 题目类型：动态规划
* 题目思路：这道题因为数据量的问题错了两次，可能是我自己没有想完整的原因，还以为是自己核心代码出错了，后来发现其实是int超范围了，必须使用long以上的数据类型才可以支持途中的运算（即使结果在int范围内）。

  一开始思路：不需要额外的dp数组，直接在原数组上面操作。（以前算法比赛其实对空间要求挺紧的……很多时候都是刚好，所以经常会想着如何节省空间）。可以选择将所有1障碍改成-1，但是这样要多进行一次二重循环，浪费时间。所以干脆将运算改成负数，即一开始初始化路径数为-1，碰到1则该格价值归零，到最后的结果为正确结果的负数，abs函数或者直接加负号就可以得到正确答案。
  
     后来知道数据超范围，意识到int不够，则查阅数据改成long（以前记错了以为long是无符号数所以第二次没用……），就修改了自己的程序变负数为正数。提升可读性，代价为多一倍的空间（因为必须另开一个dp数组，否则障碍物数值为1会对原本路径数为1的值造成影响），还是失败。
     
  第二次失败就是低级错误了：如果终点为障碍物，则直接为0，不需要任何循环，由于我是递推的动态规划模式，所以算法对最后一位是障碍物没有抗性，需要手动if判断并排除。
  
   第三次直接A过。（其实理想中第一种算法改成long就是直接正确的，不需要多开一个二维数组）

   话说题解和评论中似乎都没有提到int数据范围不够的事情……是默认都用long范围了么？
* 核心代码：				
if (obstacleGrid[i - 1][j] == 1) a = 0; else a = map[i - 1][j];
				if (obstacleGrid[i][j - 1] == 1) b = 0; else b = map[i][j - 1];
				map[i][j] = a + b;
 * 做题结果：通过/提交：1/3
执行用时超96.14% C++代码
* 时间最优解：……超级巧妙的一种解法。正常解法都需要一个最基本的二维dp数组，但是最优解只需要一维数组。
 思考以后能知道他这么做的理由，可以理解，但是让我想的话第一时间肯定是想不出来的。
 最优解思路：目前单元格可以从上来，从左来。但其实可以做到用两重循环做一维数列的事，因为从上来这个操作其实是可以被覆盖的。打个比方：正常操作就等于从左边的桶倒到右边，从上面的桶倒到下边，但其实也可以采取一直只用上边的桶，从左边倒水过来（无限水桶），同时将这个桶放到下一层。最优解采取的就是这样的操作。时间复杂度上没有减少，但是能将二维数组减少至一维，极大的节省了空间。（虽然参数就传进来了一个二维数组不用白不用不是……）但是这种方法可以在上一道题使用，就真正可以七到节省空间的作用。（但是为什么系统判断他所用时间为0ms呢。。我算出来时间复杂度不是一样的么，还是判断机制有区别导致不同做法即使理论时间复杂度相同也会得到不同的执行时间？）


      

        
